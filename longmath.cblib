function mul64_next(a_mod, b_mod, c_mod, d_mod)
    # Use the usual identity
    # a = a1 * b + a0
    # b = b1 * b + b0
    # c = (a1 * b + a0) * (b1 * b + b0)
    #   = a1 * b1 * b * b + a0 * b1 * b + b0 * a1 * b + a0 * b0
    #   = a1 * b1 * b * b + (a0 * b1 + b0 * a1) * b + a0 * b0
    # b = 2**16

    a1 = a / 0x10000 % a_mod
    a0 = a % 0x10000

    b1 = b / 0x10000 % b_mod
    b0 = b % 0x10000

    # tell @a "a0=(a0) a1=(a1) b0=(b0) b1=(b1)"

    lo = a0 * b0
    mi0 = a0 * b1
    mi1 = a1 * b0
    hi = a1 * b1

    # tell @a "lo=(lo) mi0=(mi0) mi1=(mi1) hi=(hi)"

    # Each part of c will be 16 bits so that we
    # can use simple overflow addition rules
    c0 = lo
    c1 = c0 / 0x10000 % 0x10000 + mi0 % 0x10000 + mi1 % 0x10000
    c2 = c1 / 0x10000 % 0x10000 + mi0 / 0x10000 % d_mod + mi1 / 0x10000 % c_mod + hi % 0x10000
    c3 = c2 / 0x10000 % 0x10000 + hi / 0x10000 % c_mod

    # tell @a "c0=(c0) c1=(c1) c2=(c2) c3=(c3)"

    c0 %= 0x10000
    c1 %= 0x10000
    c2 %= 0x10000
    c3 %= 0x10000

    c0 += c1 * 0x10000
    c2 += c3 * 0x10000

    # Return result in c0 (low), c1 (high)
    c1 = c2

    # tell @a "c0=(c0) c1=(c1)"
end

function mul64u(a, b)
    mul64_next(0x10000, 0x10000, 0x10000, 0x10000)
end

function mul64(a, b)
    mul64_next(0, 0, 0, 0)
end

function mul64su(a, b)
    mul64_next(0, 0x10000, 0, 0x10000)
end
